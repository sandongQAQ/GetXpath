# -*- coding: utf-8 -*-
import os
import sys

import requests
# Form implementation generated from reading ui file 'xpath.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtWidgets, QtCore
from PyQt5.QtCore import QTimer, QCoreApplication, Qt
from PyQt5.QtWidgets import QMessageBox, QCheckBox
from PyQt5.QtWidgets import *
from PyQt5.QtGui import QColor, QBrush, QPainter, QPixmap

from selenium import webdriver
from selenium.webdriver.common.by import By

from urllib.parse import urlparse, parse_qs, quote

from ui import Ui_MainWindow


js = '''
window.hovered_element = null
window.xpath = ''
function track_mouse(event){
    var x = event.clientX, y = event.clientY
    var element = document.elementFromPoint(x, y)
    if (!element) {
        window.hovered_element = null
        return // 当前位置没有元素
    } 
    window.hovered_element = element
    window.xpath=getXPath(element)
}
function getXPath(element) {
    var xpath = '';
    while (element && element.nodeType === Node.ELEMENT_NODE) {
        var id = element.getAttribute('id');
        {
            var sibling = null;
            var count = 1;
            for (sibling = element.previousElementSibling; sibling; sibling=sibling.previousElementSibling) {
                if (sibling.nodeType === Node.ELEMENT_NODE && sibling.tagName === element.tagName) {
                    count++;
                }
            }
            if (count == 1) {
                xpath = element.tagName.toLowerCase() + '/' + xpath;
            } 
            else {
                xpath = element.tagName.toLowerCase() + '[' + count + ']/' + xpath;
            }
        element = element.parentNode;
        }
    }
    return xpath.replace(/\/$/, '');
}  
window.onmousemove = track_mouse
window.urlParams = new URLSearchParams(window.location.search);
window.componentId = urlParams.get('commandId');

'''

global data
global data_input
global screen
global size

browser = None
oldelement = None
old_element = None
i=0

data_list = []


def update_xpath_entry(result, a):
    global data
    global token
    global data_input
    data = [
        a.text.replace("\n", " "),
        result,
        componentId,
        browser.current_url
        # 可能需要其他字段或信息
    ]
    if data in data_list:
        data_input = False
    else:
        data_input = True
        data_list.append(data)

class Ui_Main(QMainWindow,Ui_MainWindow):
    def __init__(self, parent=None):
        super(Ui_Main, self).__init__(parent)
        self.setupUi(self)
        global componentId
        try:
            receive_url = sys.argv[1]
            encoded_url = quote(receive_url, safe=':/?&=')
            parsed_url = urlparse(encoded_url)
            query_parameters = parse_qs(parsed_url.query)
            url = query_parameters.get('url', [None])[0]
            componentId = query_parameters.get('componentId', [None])[0]
            if componentId != None:
                QMessageBox.information(self, '消息提示', f"组件id为：{componentId}", QMessageBox.Yes)
        except:
            url = "https://www.baidu.com/"
            componentId = None
        if url == None:
            url = "https://www.baidu.com/"
            QMessageBox.warning(self, '警告', '未传入url', QMessageBox.Yes)

        if componentId == None:
            QMessageBox.warning(self, '警告', '未传入组件id', QMessageBox.Yes)

        self.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)
        self.url.setText(url)
        self.OpenPage_button.clicked.connect(self.openpage)
        self.NewUrl_button.clicked.connect(self.Newpage)
        self.OpenCatch_button.clicked.connect(self.up)
        self.OpenCatch_button.clicked.connect(self.CatchElement)
        self.timer = QTimer(None)
        self.timer2 = QTimer(None)
        self.timer.timeout.connect(self.loop)
        self.timer2.timeout.connect(self.showtime)
        self.FinishCatch_button.clicked.connect(self.FinalElement)
        self.FindXpath_button.clicked.connect(self.CatchXpath)
        self.OpenList_button.clicked.connect(self.Open_List)
        self.FinishTask_button.clicked.connect(self.close_browser)
        self.FinishCatch_button.clicked.connect(self.center)
        self.SendData_Button.clicked.connect(self.send_data)

        self.tableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        font = self.tableWidget.horizontalHeader().font()
        font.setBold(True)
        self.tableWidget.horizontalHeader().setFont(font)
        self.tableWidget.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeToContents)
        self.tableWidget.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeToContents)
        self.setWindowTitle(f"元素捕获工具（组件id为:{componentId}）")
        self.tabWidget.setStyleSheet("QTabWidget:pane {border-top:0px solid #e8f3f9;background: transparent; }")
        global screen
        global size
        # 获取屏幕坐标系
        screen = QDesktopWidget().screenGeometry()
        # 获取窗口坐标系
        size = self.geometry()
        self.count = 3
        self.tabWidget.setCurrentWidget(self.tab)

    def paintEvent(self, event):  # set background_img
        painter = QPainter(self)
        painter.drawRect(self.rect())
        script_dir = os.path.dirname(os.path.abspath(__file__))
        image_path = os.path.join(script_dir, "./background.jpg")
        pixmap = QPixmap(image_path)
        painter.drawPixmap(self.rect(), pixmap)

    def openpage(self):
        url = self.url.text()
        global browser
        if browser is not None:
            js = "window.open(" + '"' + url + '"' + ")"
            try:
                browser.execute_script(js)
            except:
                QMessageBox.warning(self.OpenPage_button, "警告", "网页已关闭，请重新开启本程序", QMessageBox.Ok)
        else:
            browser = webdriver.Firefox()
            browser.implicitly_wait(10)
            browser.maximize_window()
            browser.get(url)

    def Newpage(self):
        global browser
        try:
            all_windows = browser.window_handles
            browser.switch_to.window(all_windows[-1])
            self.url.setText(browser.current_url)
        except:
            QMessageBox.warning(self.NewUrl_button, "警告", "未打开网页", QMessageBox.Ok)

    def CatchElement(self):
        global browser
        try:
            if browser is not None:
                browser.execute_script(js)
            else:
                QMessageBox.warning(self.OpenCatch_button, "警告", "未打开网页", QMessageBox.Ok)
                self.center()
                return
        except:
            QMessageBox.warning(self.OpenCatch_button, "警告", "未打开网页", QMessageBox.Ok)
            self.center()
            return
        global oldelement
        global stop_CatchElement
        stop_CatchElement = False
        self.timer.start(3000)
        self.timer2.start(1000)

    def loop(self):
        global browser
        element = browser.execute_script('return window.hovered_element')
        global oldelement
        if stop_CatchElement:
            return
        if element:
            result_xpath = browser.execute_script('return window.xpath')
            a = browser.find_element(By.XPATH, result_xpath)
            try:
                if oldelement:
                    browser.execute_script("arguments[0].style.border='none'", oldelement)
            except:
                var = None
            resultxpath = result_xpath
            # 设置悬停元素边框----存在问题：悬停结束后未恢复
            browser.execute_script("arguments[0].style.border='2px solid red'", element)
            browser.execute_script("window.sessionStorage['xpath'] = window.xpath")
            # oldborder = browser.execute_script("return arguments[0].style.border", element)
            try:
                if element != oldelement and oldelement:
                    browser.execute_script("arguments[0].style.border='none'", oldelement)
            except:
                var = None
            oldelement = element
            self.xpath.setText(resultxpath)
            self.xpath_2.setText(resultxpath)
            #    print(f'当前鼠标所在的标签为：{element.tag_name}, 其中的文本内容为：{element.text}, 其xpath为：{resultxpath}')
            update_xpath_entry(resultxpath, a)
            if data_input:
                items = data
                row = self.tableWidget.rowCount()
                self.tableWidget.insertRow(row)
                for j in range(len(items)):
                    item = QTableWidgetItem(str(items[j]))
                    if j == 0:
                        item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
                        item.setForeground(QBrush(QColor(255, 0, 0)))  # 设置第一列的文字颜色为红色
                    elif j == 2:
                        item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
                        item.setForeground(QBrush(QColor(255, 0, 0)))  # 设置第三列的文字颜色为红色
                    else:
                        item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
                        item.setFlags(QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
                    self.tableWidget.setItem(row, j, item)
                self.check = QtWidgets.QTableWidgetItem()
                self.check.setCheckState(QtCore.Qt.Unchecked)  # 把checkBox设为未选中状态
                self.tableWidget.setItem(row, 4, self.check)

    def FinalElement(self):
        global stop_CatchElement
        global browser
        try:
            browser.switch_to_default_content()
            stop_CatchElement = True
        except:
            stop_CatchElement = True
        self.OpenCatch_button.setText("开始捕获")
        self.OpenCatch_button_2.setText("开始捕获")

    def CatchXpath(self):
        global old_element
        global browser
        var = self.lineEdit.text()
        try:
            element = browser.find_element(By.XPATH, var)
            if old_element:
                browser.execute_script("arguments[0].style.border='none'", old_element)
            browser.execute_script("arguments[0].style.border='2px solid blue'", element)
            old_element = element
        except:
            try:
                global iframe1
                result_xpath = iframe1
                iframe1 = browser.find_element(By.XPATH, result_xpath)
                browser.switch_to.frame(iframe1)
                element = browser.find_element(By.XPATH, var)
                if old_element:
                    browser.execute_script("arguments[0].style.border='none'", old_element)
                browser.execute_script("arguments[0].style.border='2px solid blue'", element)
                old_element = element
                browser.switch_to_default_content()
            except:
                QMessageBox.warning(self.FindXpath_button, "警告", "非法xpath", QMessageBox.Ok)

    def Open_List(self):
        self.tabWidget.setCurrentWidget(self.tab_2)
    def close_browser(self):
        global browser
        try:
            browser.quit()
        except:
            var = None
        QCoreApplication.instance().quit()

    def up(self):  # 定义一个函数使得窗口居中显示
        self.move(0, 0)
        self.resize(round(screen.width()), round(size.height()/2))

    def center(self):  # 定义一个函数使得窗口居中显示
        newLeft = (screen.width() - size.width()) / 2
        newTop = (screen.height() - size.height()) / 2
        self.move(int(newLeft), int(newTop))
        self.resize(size.width(), size.height())
        self.tabWidget.setCurrentWidget(self.tab)

    def showtime(self):
        if stop_CatchElement:
            return
        if self.count > 0:
            self.OpenCatch_button.setText(str(self.count) + '秒后捕获')
            self.OpenCatch_button_2.setText(str(self.count) + '秒后捕获')
            self.count -= 1
        else:
            self.OpenCatch_button.setEnabled(True)
            self.OpenCatch_button_2.setEnabled(True)
            self.OpenCatch_button.setText('3秒后捕获')
            self.OpenCatch_button_2.setText('3秒后捕获')
            self.count = 2

    def send_data(self):
        row = self.tableWidget.rowCount()
        for countlength in range(0, row):
            checkcount = self.tableWidget.item(countlength, 4).checkState()
            url = "http://172.16.26.9:8020/customize-param/add-xpath"  # 替换为实际的接口URL
            headers = {"Content-Type": "application/json", "token": "DECOUPLING:3ef63421ab0741cf85bdf776b3446b27"}  # 替换为实际的头部信息
            if checkcount != 0:
                SendData = {
                    "field": self.tableWidget.item(countlength, 0).text(),
                    "value": self.tableWidget.item(countlength, 1).text(),
                    "bizId": self.tableWidget.item(countlength, 2).text(),
                    "url": self.tableWidget.item(countlength, 3).text()
                }
                response = requests.post(url, data=SendData, headers=headers)
                if response.status_code == 200:
                    print("发送成功")
                else:
                    print("发送失败")
                response.encoding = "utf-8"
                print(response.text)

if __name__ == '__main__':
    app = QtWidgets.QApplication(sys.argv)
    mainwin = Ui_Main()
    mainwin.paintEngine()
    mainwin.show()
    sys.exit(app.exec_())